..

   restindex
   /restindex

=====================================
MetaFormat: specifying data structure
=====================================

There is a special schema in the git db store which represents the
schema of the tables itself; these are identified with the ``meta.``
schema name.  Optionally there are rows in the schema which represent
the schema of the ``meta.`` store itself.

One way to understand how this works is to see how it works out with
a simple example schema.

Meta Tables
===========

As the intrinsic storage building block, the ``meta.`` Tables have the
following restrictions;

**column types**

    All columns *must* be defined in terms of types from the standard
    type library.

**keys**

    All tables in ``meta.`` space *must* have a primary key.  Primary
    key columns must come first.

**unique constraints**

    Non-primary unique constraints are specified in terms of foreign
    key constraints to specially named tables.  In a regular database
    these tables are hidden (but you can see them in Postgres, if you
    directly inspect the catalog).
    
This is being presented like this in order to satisfy the
*bootstrapping* requirement of the schema; it should be able to store
itself, including all of the relevant constraints that you would
expect to operate on the data structure.

The "Namespace" table
=====================

The schema table defines local names of the schemas used.  This
controls the path where the data lives in the top level of the
repository.  It also allows for schema revisioning.  The repository
revision is a ``num``, which can be any number; integer, decimal,
float etc.

.. list-table::
   :widths: 5 10 10 8 20

   * - ``attr_index``
     - ``attr_name``
     - ``attr_type``
     - ``attr_required``
     - description
   * - 0
     - ``ns_name``
     - ``string``
     - true
     - name of the schema in the store
   * - 1
     - ``ns_url``
     - ``string``
     - false
     - identifier for the application
   * - 2
     - ``ns_url``
     - ``string``
     - true
     - with the URL, uniquely identifies the schema revision

The values, for the ``meta`` schema, are:

::

  { "ns_name": "meta",
    "ns_url": "http://github.com/samv/Git-DB",
    "ns_rev": 0.1,
  }

Which could be encoded in binary as:

::

  00000000  021d 6874 7470 3a2f 2f67 6974 6875 622e  ␂␝http://github.
  00000010  636f 6d2f 7361 6d76 2f47 6974 2d44 4203  com/samv/Git-DB␃
  00000020  7f01 0204 6d65 7461                      ␡␁␂␄meta


-----

Information below here is out of date; see the gidb.meta branch for
a "real" description of the meta schema structure.

-----

The "Tuple" table
=================

The "paths" table defines which schemas are active at which paths
within the git tree.  Multiple versions of the same schema can be
deployed, but they have to have unique ns_name's.

::

   { "name": "tuple",
     "type": "tuple",
     "fields": [
        { "name": "ns_url", "type": "string", "required": 1 },
        { "name": "ns_rev", "type": "num", "required": 1 },
        { "name": "tuple_index", "type": "int", "required": 1 },
        { "name": "tuple_name", "type": "string", "required": 1 },
     ],
     "keys": [
        { "primary": "1",
          "fields": [ "ns_url", "ns_rev", "tuple_index" ],
        },
        { "foreign": "1",
          "fields": [ "ns_url", "ns_rev" ],
          "references": {
              "ns_name": "meta",
              "tuple_name": "schema",
          }
        },
        { "unique": "1",
          "fields": [ "ns_url", "ns_rev", "tuple_name" ],
        },
     ],
   },

The "Store" table
=================

The tuple table defines types, but they do not necessarily "deploy"
them.  Tuples can be defined merely for use within other parts of the
schema, so this extra table connects tuples with TreeFormat_ trees.

The "path" field is actually optional, the default will be
``/ns_name/tuple_name`` but this is provided as an extra flexibility.
The only fixed path is therefore ``/.meta`` 

::

   { "name": "store",
     "type": "tuple",
     "fields": [
        { "name": "ns_name", "type": "string", "required": 1 },
        { "name": "tuple_name", "type": "string", "required": 1 },
        { "name": "ns_url", "type": "string", "required": 1 },
        { "name": "ns_rev", "type": "num", "required": 1 },
        { "name": "tuple_index", "type": "int", "required": 1 },
        { "name": "path", "type": "string", "required": 0 },
     ],
     "keys": [
        { "primary": "1",
          "fields": [ "ns_name", "tuple_name" ],
        },
        { "foreign": "1",
          "fields": [ "ns_url", "ns_rev", "tuple_index" ],
          "references": "meta.class",
        },
     ],
   },

The "Attributes" or "Columns" table
===================================

::

  # this table records the list of attributes/columns of a
  # class/table.
  meta.attr:
    **ns_url text not null**
    **ns_rev num not null**
    **tuple_index int not null**
    foreign key (ns_url, ns_rev, tuple_index)
            references meta.class
    **attr_index int not null**
    primary key (ns_url, ns_rev, tuple_index, attr_index)
    # if attr_name is null, the column is deleted.
    **attr_name text null**
    unique key (ns_url, ns_rev, tuple_index, attr_name)
    **attr_type text not null**
    foreign key (ns_url, ns_rev, attr_type) references meta.type
         (ns_url, ns_rev, type_name)
    **attr_required bool not null**
    # a 'default' is somewhat problematic; *any* value can be placed
    # here, and it is not known how to interpret it without looking up
    # what the attr_type means; so, it may be seen as 'opaque'
    **attr_default item null**

  # for unique key in above
  meta.attr:attr_name_idx
    ns_url text not null
    ns_rev num not null
    tuple_index int not null
    name text not null
    primary key (ns_url, ns_rev, tuple_index, name)
    attr_index int not null
    foreign key (ns_url, ns_rev, tuple_index, attr_index)
            references meta.attr

In Avro-like syntax:


Precision/scale modifiers, such as ``VARCHAR(2)`` etc are not
supported directly; they're something of a bodge when proper
generics/higher order type system is a more complete solution.  Done
properly, a generics system can also be the starting point for
features such as arrays (ARRAY [TYPE]) and composite types (eg TUPLE
[TYPE, TYPE, TYPE]); so this will be left out initially, and the
database will be fully arbitrary length throughout.

KEYS & KEY CONSTRAINTS
======================

::

  # the 'key' table describes unique and foreign key constraints as
  # well as listing recommended indexes (stored=false)
  meta.key:
    **ns_url text not null**
    **ns_rev num not null**
    **tuple_index int not null**
    foreign key (ns_url, ns_rev, tuple_index)
            references meta.class
    **key_name text not null**
    primary key (ns_url, ns_rev, tuple_index, key_name)
    **key_unique bool not null**
    **key_primary bool not null**
    **key_stored bool not null**
    # whether this key also restricts subclasses of the parent.
    # subclasses will have multiple key rows!
    **key_heritable bool not null**

  # this slave table links the key to the (ordered) list of attributes
  # which are a part of the key, and if the key is a foreign key, then
  # also the columns of the foreign key.
  meta.key:attr
    **ns_url text not null**
    **ns_rev num not null**
    **tuple_index int not null**
    **key_name text not null**
    foreign key (ns_url, ns_rev, tuple_index, key_name)
            references meta.key
    **key_pos int not null**
    primary key (ns_url, ns_rev, tuple_index, name, key_pos)
    attr_index int not null
    foreign key (ns_url, ns_rev, tuple_index, attr_index)
            references meta.attr
    foreign_tuple_index int null
    foreign key (ns_url, ns_rev, foreign_tuple_index)
            references meta.class (ns_url, ns_rev, tuple_index)
    foreign_attr_index int null
    foreign key (ns_url, ns_rev, foreign_tuple_index, foreign_attr_index)
            references meta.attr (ns_url, ns_rev, tuple_index, attr_index)

.. _types:

Types
=====

::

  # meta.type: this is basically a compatibility table and is optional
  # if using only predefined types.  'Functions' here are strings;
  # only the name, not the definition nor the function prototype are
  # represented.  They are to be well-known function names, but the
  # paranoid should prepare for them to be custom to the schema
  # ID/revision.
  meta.type:
    **ns_url text not null**
    **ns_rev num not null**
    foreign key (id, ns_rev) references meta.schema
    **type_name text not null**
    primary key (id, ns_rev, type_name)
    **type_formats int not null**
    **type_dump_func text null**
    **type_load_func text null**
    **type_choose_func text null**
    **type_cmp_func text null**
    **type_print_func text null**
    **type_scan_func text null**

``type_formats`` is an integer which is interpreted bitwise, and
represents the encodings which are allowed for that type in this
store.  The values for the standard types, below, represent all of the
encodings which are defined by this standard.  Using an encoding for a
type which is not permitted by the ``type_formats`` value in the
``meta.type`` table is a data consistency error.  ``type_formats``
roughly covers the ``INTERNALLENGTH`` and ``STORAGE`` properties in
the equivalent Postgres feature, ``CREATE TYPE``

The functions are described as below:

``type_choose_func``

    Some types get to choose the encoding based on the value to be
    encoded.  If that is true, this function will be defined,
    otherwise it will be null and only one ``type_formats`` bit may be
    set.
  
``type_dump_func``

    The name of a function which marshalls the value out.  The
    function will take the value, an encoding, and return a value
    valid for that encoding.  This is similar to the ``SEND`` function
    in Postgres.
  
``type_load_func``

    The reverse, but marshalls the value in.  The encoding is a formal
    parameter.  This corresponds to ``RECEIVE`` in Postgres.
  
``type_cmp_func``

    The name of a function which can compare two values.  For primary
    key sorting purposes.  This corresponds to the ``CREATE OPERATOR
    CLASS ... DEFAULT FOR TYPE ... USING BTREE`` command in Postgres.
  
``type_print_func``

    The name of a function which converts the value to a primary
    key-form string, like ``OUTPUT`` in Postgres.  This need not be
    reversible; if not, the standard types' function name starts with
    ``hash_``
  
``type_scan_func``

    The reverse of ``type_print_func``; turns a formatted string back
    into a value, like ``INPUT`` in Postgres.  If this is not
    reversible then the function will be converting the row value to a
    placeholder.
  
Types do not need to specify a hashing function as in Postgres; this
is considered an internal implementation detail.  As truly custom
types are not yet permitted, hashing may proceed on the basis of the
encoded value.

Standard Types
--------------

The *standard types* here represent a common set of well known
data types in use in databases and programming, and a corresponding
set of *well known functions* which perform the trivial IO
operations, and for which reference implementations will be provided.

Implementations need not support all types; however if opening a
store, this table may be checked to see that the understanding of all
parties as to the nature of the types is known.

.. list-table:
   :widths: 12 12 12 12 12 12 12 12

   * - ``type_name``
     - ``type_formats``
     - ``type_choose_func``
     - ``type_dump_func``
     - ``type_load_func``
     - ``type_cmp_func``
     - ``type_print_func``
     - ``type_scan_func``
   * - bool
     - 1100000b
     - is_tf
     - emit_bool
     - read_bool
     - false_first
     - fmt_bool
     - scan_bool
   * - integer
     - 1b
     - -
     - emit_varint
     - read_varint
     - cmp_num
     - fmt_int
     - scan_int
   * - real
     - 11011b
     - pack_real
     - emit_real
     - read_real
     - cmp_num
     - fmt_real
     - scan_real
   * - numeric
     - 1000b
     - -
     - emit_real
     - read_real
     - cmp_num
     - fmt_real
     - scan_real
   * - bytea
     - 1000100b
     - large_value
     - emit_bytea
     - read_bytea
     - cmp_bytes
     - fmt_bytea_hex
     - scan_bytea_hex
   * - text
     - 1000100b
     - large_value
     - emit_text
     - read_text
     - cmp_text
     - fmt_text
     - scan_text
   * - nkd_text
     - 1000100b
     - large_value
     - emit_nkd_text
     - read_nkd_text
     - cmp_nkd_text
     - fmt_nkd_text
     - scan_nkd_text
   * - nkc_text
     - 1000100b
     - large_value
     - emit_nkc_text
     - read_nkc_text
     - cmp_nkc_text
     - fmt_nkc_text
     - scan_nkc_text
   * - json
     - 1000100b
     - large_json
     - emit_json
     - read_json
     - cmp_struct_hash
     - hash_json
     - scan_hash

The functions are all described in detail in the reference
implementation.  Most are very simple.

If a ``type_name`` is used in the schema, but not listed in
``meta.types``, then the above definitions are used.

.. _TreeFormat:
   ./treeformat.html
