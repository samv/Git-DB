<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <title>MetaFormat: specifying data structure</title>
    <link rel="stylesheet" href="../gitdb.css" type="text/css" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="description" content="gitdb - decentralized, replicating transactional store" />
    <meta name="author" content="Sam Vilain" />
    <meta name="copyright" content="&copy; 2009-2011 Sam Vilain" />
    <meta name="keywords" content="gitdb, Git-DB, database, decentralized, transactional, ACID, git, avro, thrift, IDL, Protocol Buffers,
    " />
</head>
<body>
  <div id="sitelogo">
    <a href="../index.html">
      <img id="logo" src="../files/gitdb-logo.png" border="0" />
      <div id="titlebox">
        <span id="site_title">git db</span>
        <span id="site_strapline">decentralized data storage in git</span>
      </div>
    </a>
  </div>

  <div id="navbar">
    <div class="menuItem">
      <a href="../design/index.html" class="menu">Design</a>
    </div>
    <div class="menuItem">
      <a href="../code.html" class="menu">Code</a>
    </div>
    <div class="menuItem">
      <a href="../examples.html" class="menu">Examples</a>
    </div>
  </div><!-- id="navbar" -->

    <ul id="breadcrumbs">
      <li><a href="../index.html">Index</a></li>
<li>&gt;</li>
<li><a href="index.html">Design</a></li>
<li>&gt;</li>
<li>MetaFormat: specifying data structure</li>

    </ul>

  <div id="body">
    <div class="document" id="metaformat-specifying-data-structure">
<h1 class="title">MetaFormat: specifying data structure</h1>
<div class="figure align-right" style="width: 80%">
<img alt="UML diagram showing relationship between meta class heirarchies" src="../files/meta-uml-simple.png" style="width: 40%;" />
<p class="caption"><strong>Figure 1.</strong> How the various <tt class="docutils literal">meta</tt> types relate to each other,
as UML.  This is a simplified overview.</p>
</div>
<p>There is a special schema in the git db store which represents the
schema of the tables itself; these are identified with the <tt class="docutils literal">meta.</tt>
schema name.  Optionally there are rows in the schema which represent
the schema of the <tt class="docutils literal">meta.</tt> store itself.</p>
<p>One way to understand how this works is to see how it works out with
a simple example schema.</p>
<div class="section" id="meta-tables">
<h1>Meta Tables</h1>
<p>As the intrinsic storage building block, the <tt class="docutils literal">meta.</tt> schema defines
the tables that exist in the store.</p>
<p>The <tt class="docutils literal">meta.</tt> schema is rich enough to express itself, as well as a
number of useful features such as inheritance, nested tuples, and
basic keys.</p>
<p>There are four groups of <tt class="docutils literal">meta</tt> tables:</p>
<p><strong>namespace</strong></p>
<blockquote>
The objects in this table are top-level containers for all the
schema objects relating to a particular version of the application.
When querying, this specifies the name that can be used to specify
the schema for objects.</blockquote>
<p><strong>types</strong></p>
<blockquote>
<p>The type system uses (strict) inheritance, with all types sharing a
common (abstract) base type, <tt class="docutils literal">meta.types</tt>.</p>
<p>As is described later, this also implies that they share a primary
key.  This is different to Postgres, on which inherited types do
not share keys.  In the <tt class="docutils literal">meta</tt> schema, they will also share the
same storage path, <tt class="docutils literal">/meta/types</tt>.</p>
<p>Types can be value types (<tt class="docutils literal">meta.value</tt>), tuples (<tt class="docutils literal">meta.tuple</tt>)
or storage tables (<tt class="docutils literal">meta.table</tt>).</p>
</blockquote>
<p><strong>attributes</strong></p>
<blockquote>
<p>Tuples are comprised of an ordered set of attributes.  Taken
together, these attributes define the tuple type.</p>
<p>Each attribute has a type, which can be a basic type or a tuple, as
described above.</p>
</blockquote>
<p><strong>keys</strong></p>
<blockquote>
There are three types of keys.  Primary keys, foreign keys, and
unique keys.  Every key belongs to a table (called the <em>source</em>
table), and all the attributes that it refers to are found in the
source table.  There are no indexes in this version of gitdb.</blockquote>
</div>
<div class="section" id="the-namespace-table-meta-namespace">
<h1>The Namespace table (<tt class="docutils literal">meta.namespace</tt>)</h1>
<p>The namespace table is a local surrogate key given to the schema,
which is used as the first member of the primary key for all the other
types in the <tt class="docutils literal">meta</tt> schema.</p>
<p>The namespace has a URL and revision pair.  The URL is a
distinguishing feature of the schema.  The revision number is
increased as the schema is modified going forward.  The meta schema
itself can store multiple revisions of a single application's database
schema, under different names.</p>
<p>Here is a table describing the structure.  The first four colums of
this table are equivalent to a query like:</p>
<pre class="literal-block">
select
   attr_index, attr_name, attr_type, attr_required
from meta.attr
where ns_name = 'meta'
  and type_name = 'namespace'
</pre>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="17%" />
<col width="17%" />
<col width="8%" />
<col width="33%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">attr_index</th>
<th class="head">attr_name</th>
<th class="head">attr_type</th>
<th class="head">attr_required</th>
<th class="head">Description</th>
<th class="head">Key(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>0</td>
<td><tt class="docutils literal">ns_name</tt></td>
<td><tt class="docutils literal">string</tt></td>
<td>yes</td>
<td>local schema name</td>
<td>Primary</td>
</tr>
<tr><td>1</td>
<td><tt class="docutils literal">ns_url</tt></td>
<td><tt class="docutils literal">string</tt></td>
<td>yes</td>
<td>uniquely identitying URL (may be empty)</td>
<td>Unique (with ns_rev)</td>
</tr>
<tr><td>2</td>
<td><tt class="docutils literal">ns_rev</tt></td>
<td><tt class="docutils literal">num</tt></td>
<td>yes</td>
<td>schema iteration number</td>
<td>Unique (with ns_rev)</td>
</tr>
</tbody>
</table>
<p>If you are storing in a verbose encoding such as JSON, then the
attribute indices are not important and property names are used
instead.  For example, the <tt class="docutils literal">meta</tt> schema could be declared with this
entry in <tt class="docutils literal">/meta/namespace.json</tt> (or <tt class="docutils literal">/meta/namespace/meta.json</tt>):</p>
<pre class="literal-block">
{ &quot;ns_name&quot;: &quot;meta&quot;,
  &quot;ns_url&quot;: &quot;http://github.com/samv/Git-DB&quot;,
  &quot;ns_rev&quot;: 0.1,
}
</pre>
<p>It could also be encoded in binary as:</p>
<pre class="literal-block">
00000000  0204 6d65 7461 021d 6874 7470 3a2f 2f67 ␂␄meta␂␝http://g
00000010  6974 6875 622e 636f 6d2f 7361 6d76 2f47 ithub.com/samv/Gi
00000020  6974 2d44 4203 7f01                     t-DB␃␡␁
</pre>
<p>This shows a curious situation, in that it is possible to include
information in the <tt class="docutils literal">meta</tt> tables about the <tt class="docutils literal">meta</tt> schema itself.
This is a well-known chicken-and-egg situation, found in type theory,
metaprogramming, etc.</p>
<p>To keep things simple when connecting, all that is required is a
single row which includes the <tt class="docutils literal">meta</tt> schema URL and revision - and
if the implementation does not know how what that means, it cannot
process the rest of the schema metadata, and therefore should not
continue.  If the data is provided, then it should be compared against
the known good data, and any discrepancies treated as a fatal error.</p>
</div>
<div class="section" id="types-meta-type">
<h1>Types (<tt class="docutils literal">meta.type</tt>)</h1>
<p>Types are abstract, in that you can't just have a type, it has to be a
particular kind of type.  When reading the row, which kind of type you
have can be distinguished from which attributes it posesses.</p>
<p>The <tt class="docutils literal">type</tt> tuple exists only to keep a registry of type names within
a namespace.  The primary namespace for types is their names and not a
surrogate index, which makes type renaming more complex, but makes the
schema overall nicer to work with.  Numbered surrogates are used for
the <tt class="docutils literal">attr</tt> table, only, as they are necessary for the binary column
format.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="7%" />
<col width="7%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Nullable</th>
<th class="head">Key(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">ns_name</tt></td>
<td>string</td>
<td>no</td>
<td>Primary (with <tt class="docutils literal">type_name</tt>) and Foreign to <tt class="docutils literal">namespace</tt></td>
</tr>
<tr><td><tt class="docutils literal">type_name</tt></td>
<td>string</td>
<td>no</td>
<td>Primary (with <tt class="docutils literal">ns_name</tt>)</td>
</tr>
</tbody>
</table>
<div class="section" id="value-types-meta-value">
<h2>Value Types (<tt class="docutils literal">meta.value</tt>)</h2>
<p>Value Types are a kind of type that are simple and concrete: they have
a single set of allowable column formats, and well-known set of
functions for converting from the value to representations such as the
tree format and the column format.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="7%" />
<col width="7%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Nullable</th>
<th class="head">Key(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">ns_name</tt></td>
<td>string</td>
<td>no</td>
<td>Primary (with <tt class="docutils literal">type_name</tt>); foreign key inherited from
<tt class="docutils literal">type</tt></td>
</tr>
<tr><td><tt class="docutils literal">type_name</tt></td>
<td>string</td>
<td>no</td>
<td>Primary (with <tt class="docutils literal">ns_name</tt>)</td>
</tr>
<tr><td><tt class="docutils literal">value_formats</tt></td>
<td><tt class="docutils literal">column_formats</tt></td>
<td>no</td>
<td>-</td>
</tr>
<tr><td><tt class="docutils literal">value_dump_f</tt></td>
<td>string</td>
<td>yes</td>
<td>-</td>
</tr>
<tr><td><tt class="docutils literal">value_load_f</tt></td>
<td>string</td>
<td>yes</td>
<td>-</td>
</tr>
<tr><td><tt class="docutils literal">value_choose_f</tt></td>
<td>string</td>
<td>yes</td>
<td>-</td>
</tr>
<tr><td><tt class="docutils literal">value_cmp_f</tt></td>
<td>string</td>
<td>yes</td>
<td>-</td>
</tr>
<tr><td><tt class="docutils literal">value_print_f</tt></td>
<td>string</td>
<td>yes</td>
<td>-</td>
</tr>
<tr><td><tt class="docutils literal">value_scan_f</tt></td>
<td>string</td>
<td>yes</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>Value Type definitions are relatively mundane, so the meanings of
these columns is described elsewhere, in <a class="reference external" href="./values.html">Value Types</a>.  You can
include this in your schema to assist others in working with the new
data types that get defined, should you feel the need.</p>
</div>
<div class="section" id="enum-types-meta-enum">
<h2>Enum Types (<tt class="docutils literal">meta.enum</tt>)</h2>
<p>Enums.  Useful enough to include on a first cut.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="7%" />
<col width="7%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Nullable</th>
<th class="head">Key(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">ns_name</tt></td>
<td>string</td>
<td>no</td>
<td>Primary (with <tt class="docutils literal">type_name</tt>); foreign key inherited from
<tt class="docutils literal">type</tt></td>
</tr>
<tr><td><tt class="docutils literal">type_name</tt></td>
<td>string</td>
<td>no</td>
<td>Primary (with <tt class="docutils literal">ns_name</tt>)</td>
</tr>
<tr><td><tt class="docutils literal">enum_values</tt></td>
<td>string[]</td>
<td>no</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">enum_values</tt> is a column with 1 dimension, that is, an array.  The
contents of this array relate to 'int' values.</p>
</div>
<div class="section" id="field-types-meta-field">
<h2>Field Types (<tt class="docutils literal">meta.field</tt>)</h2>
<p>Fields are like 'enum's but stored bitwise, either in an int or a
block of bytes.  May be mapped to an array of values, or a 'FOO|BAR'
C-style rendering, depending on the IO functions specified.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="7%" />
<col width="7%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Nullable</th>
<th class="head">Key(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">ns_name</tt></td>
<td>string</td>
<td>no</td>
<td>Primary (with <tt class="docutils literal">type_name</tt>); foreign key inherited from
<tt class="docutils literal">type</tt></td>
</tr>
<tr><td><tt class="docutils literal">type_name</tt></td>
<td>string</td>
<td>no</td>
<td>Primary (with <tt class="docutils literal">ns_name</tt>)</td>
</tr>
<tr><td><tt class="docutils literal">field_bits</tt></td>
<td>string[]</td>
<td>no</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>Fields are included mainly because there is one in the meta schema.</p>
</div>
<div class="section" id="tuples-meta-tuple">
<h2>Tuples (<tt class="docutils literal">meta.tuple</tt>)</h2>
<p>The tuple table defines what Postgres would call compound data types,
and are usually called tables in the classic RDBMS, or perhaps classes
or result sets in other contexts.</p>
<p>Similar to the situation in Postgres, they are not necessarily
intended for use as real tables, and can be used as column types in
the case of nested data types.  This allows for deeply nested data in
rows, while retaining the ability to use strict typing.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="7%" />
<col width="7%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Nullable</th>
<th class="head">Key(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">ns_name</tt></td>
<td>string</td>
<td>no</td>
<td>Primary (with <tt class="docutils literal">type_name</tt>); foreign key inherited from
<tt class="docutils literal">type</tt></td>
</tr>
<tr><td><tt class="docutils literal">type_name</tt></td>
<td>string</td>
<td>no</td>
<td>Primary (with <tt class="docutils literal">ns_name</tt>)</td>
</tr>
<tr><td><tt class="docutils literal">tuple_super</tt></td>
<td>string[]</td>
<td>yes</td>
<td>Foreign, with <tt class="docutils literal">ns_name</tt>, to <tt class="docutils literal">type</tt> primary key</td>
</tr>
</tbody>
</table>
<p>Tuples can inherit from other tuples, but they must add at least one
required attribute in order to distinguish themselves in storage.
This restriction allows row data to be merged between tables by simple
concatenation and avoids storing schema information in the data. In
other words, types within an inheritance heirarchy share attribute
numbering ranges.</p>
</div>
<div class="section" id="storage-tables-meta-table">
<h2>Storage Tables (<tt class="docutils literal">meta.table</tt>)</h2>
<p>A tuple with storage is called a table, and this requires a primary
key.</p>
<p>By default, its storage path is <tt class="docutils literal">/ns_name/type_name</tt> - but this can
be overridden by a non-null value in the <tt class="docutils literal">table_path</tt> column.  The
only fixed path in the repository is therefore <tt class="docutils literal">/meta</tt> - though you
can call this path <tt class="docutils literal">/_meta</tt> or <tt class="docutils literal">/.meta</tt> if you prefer.  On
connection, they should be tried in that order, and the first one
found used.  If a <tt class="docutils literal">value_name</tt> is used in the schema, but not listed
in <tt class="docutils literal">meta.types</tt>, then 'standard' definitions from the relevant
version of the git-db spec may be used.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="7%" />
<col width="7%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Nullable</th>
<th class="head">Key(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">ns_name</tt></td>
<td>string</td>
<td>no</td>
<td>Primary (with <tt class="docutils literal">type_name</tt>); foreign key inherited from
<tt class="docutils literal">type</tt></td>
</tr>
<tr><td><tt class="docutils literal">type_name</tt></td>
<td>string</td>
<td>no</td>
<td>Primary (with <tt class="docutils literal">ns_name</tt>)</td>
</tr>
<tr><td><tt class="docutils literal">tuple_super</tt></td>
<td>string[]</td>
<td>yes</td>
<td>(inherited from tuple)</td>
</tr>
<tr><td><tt class="docutils literal">tuple_path</tt></td>
<td>string</td>
<td>no</td>
<td>none</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="the-attribute-table-meta-attr">
<h1>The Attribute table (<tt class="docutils literal">meta.attr</tt>)</h1>
<p>Tuples are ordered lists of attributes.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="7%" />
<col width="7%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Nullable</th>
<th class="head">Key(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">ns_name</tt></td>
<td>string</td>
<td>no</td>
<td>Primary (1/3)</td>
</tr>
<tr><td><tt class="docutils literal">type_name</tt></td>
<td>string</td>
<td>no</td>
<td>Primary (2/3); Foreign with <tt class="docutils literal">ns_name</tt> to <tt class="docutils literal">type</tt> or
<tt class="docutils literal">tuple</tt></td>
</tr>
<tr><td><tt class="docutils literal">attr_index</tt></td>
<td>int</td>
<td>no</td>
<td>Primary (3/3)</td>
</tr>
<tr><td><tt class="docutils literal">attr_name</tt></td>
<td>int</td>
<td>yes</td>
<td>Unique with <tt class="docutils literal">ns_name</tt> and <tt class="docutils literal">type_name</tt></td>
</tr>
<tr><td><tt class="docutils literal">attr_type</tt></td>
<td>string</td>
<td>yes</td>
<td>Foreign with <tt class="docutils literal">ns_name</tt> to <tt class="docutils literal">type</tt> primary key index</td>
</tr>
<tr><td><tt class="docutils literal">attr_dim</tt></td>
<td>int</td>
<td>yes</td>
<td>none</td>
</tr>
<tr><td><tt class="docutils literal">attr_required</tt></td>
<td>bool</td>
<td>no</td>
<td>none</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">ns_name</tt>, <tt class="docutils literal">type_name</tt></p>
<blockquote>
These parts of the primary key are a foreign keys to the <tt class="docutils literal">tuple</tt>
table (or the <tt class="docutils literal">type</tt> table, but they really only may add
attributes to tuple types, as value types cannot have extra type
encoded).  They specify the <tt class="docutils literal">meta.tuple</tt> that the entry
describes.</blockquote>
<p><tt class="docutils literal">attr_index</tt></p>
<blockquote>
This specifies the column number in storage.  When new columns are
added, they are given a new <tt class="docutils literal">attr_index</tt> number.  When they are
renamed, the number stays the same, and finally, when they are
deleted the entry remains.</blockquote>
<p><tt class="docutils literal">attr_name</tt></p>
<blockquote>
This is the logical name that is ascribed to the property, and
should be the important one as far as applications are concerned.
As there is a unique constraint, attributes which are deleted
should have <tt class="docutils literal">attr_name</tt> not set.</blockquote>
<p><tt class="docutils literal">attr_type</tt></p>
<blockquote>
<p>This specifies the type of the attribute.  It is a reference to
the <tt class="docutils literal">meta.type</tt> heirarchy.  Through inheritance, this may also
refer to tuples in the <tt class="docutils literal">meta.tuple</tt> table - even itself.
Cross-namespace type references are not allowed.</p>
<p>If this field is not set then the attribute is untyped.  The
standard JSON-like transform rules will apply.</p>
</blockquote>
<p><tt class="docutils literal">attr_dim</tt></p>
<blockquote>
This specifies the number of dimensions of the attribute.  If it
is 0 or not specified, then the attribute is a regular attribute.
If it is 1, then it is an array.  If 2 or higher, a
multi-dimensional array.</blockquote>
<p><tt class="docutils literal">attr_required</tt></p>
<blockquote>
A most basic constraint, whether the value can be NULL or not.  If
not set, then the value may be NULL.  No primary key attributes
may be NULL.</blockquote>
</div>
<div class="section" id="constraints-and-keys">
<h1>Constraints and Keys</h1>
<p>There are three types of indexes: primary keys, unique keys, and
foreign keys.  These are all specializations of the 'key' tuple:</p>
<div class="section" id="the-key-tuple-meta-key">
<h2>The Key Tuple (<tt class="docutils literal">meta.key</tt>)</h2>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="7%" />
<col width="7%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Nullable</th>
<th class="head">Key(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">ns_name</tt></td>
<td>string</td>
<td>no</td>
<td>Primary (1/3)</td>
</tr>
<tr><td><tt class="docutils literal">type_name</tt></td>
<td>string</td>
<td>no</td>
<td>Primary (2/3); Foreign with <tt class="docutils literal">ns_name</tt> to <tt class="docutils literal">type</tt> or
<tt class="docutils literal">tuple</tt></td>
</tr>
<tr><td><tt class="docutils literal">key_name</tt></td>
<td>int</td>
<td>no</td>
<td>Primary (3/3); Unique with <tt class="docutils literal">ns_name</tt></td>
</tr>
<tr><td><tt class="docutils literal">key_inherit</tt></td>
<td>bool</td>
<td>yes</td>
<td>This rule doesn't apply to sub-types.</td>
</tr>
<tr><td><tt class="docutils literal">key_attr_index</tt></td>
<td>int[]</td>
<td>yes</td>
<td>Foreign with <tt class="docutils literal">ns_name</tt> and <tt class="docutils literal">type_name</tt> to
<tt class="docutils literal">attr_ns_name_type_name_attr_index_unique</tt></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="unique-keys-meta-unique">
<h2>Unique Keys (<tt class="docutils literal">meta.unique</tt>)</h2>
<p>Unique keys add the notion of constraint on the source table.</p>
<p>It has a table, which has no extra columns compared to the tuple.</p>
</div>
<div class="section" id="primary-keys-meta-primary">
<h2>Primary Keys (<tt class="docutils literal">meta.primary</tt>)</h2>
<p>The only difference between the primary key and a unique key is that
it is used as the primary identity for rows in the table.  It stores
one extra fact, the location of the table in the store.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="7%" />
<col width="7%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Nullable</th>
<th class="head">Key(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">ns_name</tt>, <tt class="docutils literal">type_name</tt>, <tt class="docutils literal">key_name</tt>, <tt class="docutils literal">key_inherit</tt>,
<tt class="docutils literal">key_attr_index</tt></td>
<td>various</td>
<td>various</td>
<td>Inherited from 'key' tuple</td>
</tr>
<tr><td><tt class="docutils literal">primary_path</tt></td>
<td>string</td>
<td>no</td>
<td>no key, must exist</td>
</tr>
</tbody>
</table>
<p>There are two fields where the path is recorded; this one records the
location of the TreeFormat structure.  Technically, the <tt class="docutils literal">table</tt>
class' <tt class="docutils literal">table_path</tt> attribute records which TreeFormat structure
that this table is saving its rows in.</p>
</div>
<div class="section" id="foreign-keys-meta-foreign">
<h2>Foreign Keys (<tt class="docutils literal">meta.foreign</tt>)</h2>
<p>Finally, there is the <tt class="docutils literal">foreign</tt> key type.  Foreign keys refer to
another key.  If they refer to a unique or primary key, a traditional
foreign key relationship is established.  Foreign keys which refer to
each other imply the existence test, but place no constraint on
uniqueness of either side.</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="7%" />
<col width="7%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Column</th>
<th class="head">Type</th>
<th class="head">Nullable</th>
<th class="head">Key(s)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">ns_name</tt>, <tt class="docutils literal">type_name</tt>, <tt class="docutils literal">key_name</tt>, <tt class="docutils literal">key_inherit</tt>,
<tt class="docutils literal">key_attr_index</tt></td>
<td>various</td>
<td>various</td>
<td>Inherited from 'key' tuple</td>
</tr>
<tr><td><tt class="docutils literal">foreign_key_name</tt></td>
<td>string</td>
<td>no</td>
<td>Foreign to <tt class="docutils literal">key</tt> with <tt class="docutils literal">ns_name</tt></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="summary">
<h1>Summary</h1>
<p>The schema so far is capable of storing typed and untyped data, as
well as achieving several of the various levels of normal form.  An
important test is that the schema completely describes itself, and
naturally fits within itself.</p>
<div class="figure align-right" style="width: 90%">
<img alt="UML diagram showing relationship between all meta classes" src="../files/meta-uml.png" style="width: 60%;" />
<p class="caption"><strong>Figure 2.</strong> A UML diagram of <em>all</em> of the <tt class="docutils literal">meta</tt> types and how
they relate to each other.</p>
</div>
</div>
</div>

  </div>

  <div id="footer" style="clear: both">
   <hr />
   <a href="../copyright.html">copyright info</a> |
   <a href="../map.html">site map</a>
  </div>

</body>
</html>
