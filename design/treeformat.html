<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <title>TreeFormat: arranging data</title>
    <link rel="stylesheet" href="../gitdb.css" type="text/css" />
    <meta http-equiv="Content-Type" content="text/html; charset=ISO8859-1" />
    <meta name="description" content="gitdb - decentralized, replicating transactional store" />
    <meta name="author" content="Sam Vilain" />
    <meta name="copyright" content="&copy; 2009-2011 Sam Vilain" />
    <meta name="keywords" content="gitdb, Git-DB, database, decentralized, transactional, ACID, git, avro, thrift, IDL, Protocol Buffers,
    " />
</head>
<body>
  <div id="sitelogo">
    <a href="../index.html">
      <img id="logo" src="../files/gitdb-logo.png" border="0" />
      <div id="titlebox">
        <span id="site_title">git db</span>
        <span id="site_strapline">decentralized data storage in git</span>
      </div>
    </a>
  </div>

  <div id="navbar">
    <div class="menuItem">
      <a href="../design/index.html" class="menu">Design</a>
    </div>
    <div class="menuItem">
      <a href="../code.html" class="menu">Code</a>
    </div>
    <div class="menuItem">
      <a href="../examples.html" class="menu">Examples</a>
    </div>
  </div><!-- id="navbar" -->

    <ul id="breadcrumbs">
      <li><a href="../index.html">Index</a></li>
<li>&gt;</li>
<li><a href="index.html">Design</a></li>
<li>&gt;</li>
<li>TreeFormat: arranging data</li>

    </ul>

  <div id="body">
    <div class="document" id="treeformat-arranging-data">
<h1 class="title">TreeFormat: arranging data</h1>
<div class="section" id="treeformat-basics">
<h1>TreeFormat basics</h1>
<p>The starting point of the design is to use the schema name at the top
level, table/relation name next, and then within those, a zero-padded
sort number, a space and a UTF-8 representation of the value of the
primary key(s) of the row (or a UUID if there is no primary key) as
the filename within the tree for the relation.</p>
<p>eg</p>
<pre class="literal-block">
tracker/ticket/1 1.row
tracker/ticket/2 2.row
</pre>
<p>The exact mechanism for converting from a value to the above
representation is type-dependent, and covered by the &lt;a
href=&quot;[%link('design/filenames.tt')%]&quot;&gt;Filename format&lt;/a&gt;).  The
mechanism to know what the directory names mean is covered by the &lt;a
href=&quot;[%link('design/meta.tt')%]&quot;&gt;MetaFormat&lt;/a&gt;.  To solve the
re-entrancy problem, a &quot;meta&quot; directory exists at the top level which
contains fixed directories such as &quot;class&quot;, &quot;types&quot; and &quot;attr&quot;.</p>
</div>
<div class="section" id="dividing-large-directories">
<h1>Dividing large directories</h1>
<p>For relations with a lot of contents, trees can be used.  This is
equivalent to use of nodes in a B-Tree.  The name of a tree can either
be a single value or a range.</p>
<pre class="literal-block">
tracker/ticket/1 1-1000/1 1.row
tracker/ticket/2 1001-2000/1 1001.row
</pre>
<p>If it is a value, it must correspond to an entire key column (and
there must be subsequent primary key columns).</p>
<p>The problem of deciding when to divide a large directory, and when to
&quot;rebalance&quot; the tree, so as to try to ensure an even depth of index,
are long-standing data management problems which this specification
will not try to wave a magic wand to make go away.  More on that in
the below section.</p>
</div>
<div class="section" id="sort-numbers">
<h1>Sort numbers</h1>
<p>One of the things that this specification tries to ensure is that the
back-end as a whole has good enough design performance to be used for
a live database back-end.</p>
<p>As such, the method described above for allowing arbitrary division of
directories into smaller fragments, makes the structure as a whole a
B+ tree, or depending on the rebalancing style, a more advanced form
such as a B* tree.  These types of trees are widely used internally in
databases to record row locations and for ordered indexes, because
they are well understood, and generally thought to be about as fast as
you can get and still allow very large scalability.</p>
<p>In Git DB, the git tree objects are the 'nodes' in the B+ tree, and
the blobs are the 'leaves'.</p>
<p>However for B+trees to work, a couple of conditions must hold true for
the nodes:</p>
<ol class="arabic simple">
<li>Nodes should be fast to locate entries in</li>
<li>Nodes should be fast to scan in order</li>
</ol>
<p>Typically, the &quot;fan out&quot; of a B+ tree is of the order of about a 100
in each directory before it is &quot;split&quot; into two or three balanced
children.  The B* tree performs a partial rebalancing at this point to
make the neighbours also relatively balanced with each other.</p>
<p>Assuming such a large fan-out, random access needs to be fast, but
unless the entries in the tree are in order, it is impossible to use
binary search to locate the item or range you are looking for.
Hash-based solutions are not applicable to the B-Tree.</p>
<p>Unfortunately, there is no way to specify the order of entries in a
git tree.  They are always sorted by string value.  And only a very
few types will naturally sort correctly after conversion and escaping.</p>
<p>To solve this problem, the sort number is introduced.  It is designed
to override the filename, so that the entries will always be stored in
the correct order.  When writing a tree for the first time, the
appropriate number of digits are used, zero padded, and starting at 1.</p>
<p>eg</p>
<pre class="literal-block">
role/voter/1 Jones,Bob.row
role/voter/2 MacDonald,Ronald.row
role/voter/3 Mace,The.row
role/voter/4 MacGuyver,James.row
role/voter/5 Nelson,Willie.row
</pre>
<p>Let's say that a new entry, &quot;Woody Allen&quot; comes along.  We need to
insert a new number at the beginning.  At this point, one of two
things happens:</p>
<ul>
<li><p class="first">If it makes an implementation simpler, it can renumber all of the
entries in that tree.  This can still be fast enough and is simple
string operations to enact.  It only affects the tree which is being
inserted into, which has to be re-written back to the object
database anyway:</p>
<pre class="literal-block">
role/voter/1 Allen,Woody.row
role/voter/2 Jones,Bob.row
role/voter/3 MacDonald,Ronald.row
role/voter/4 Mace,The.row
role/voter/5 MacGuyver,James.row
role/voter/6 Nelson,Willie.row
</pre>
</li>
<li><p class="first">However if it does matter, because either there is an index which
would otherwise have to be updated and recursively moved sub-entries
around, or perhaps just it is desired to make directories which
delta more efficiently, then it can insert a new entry before: ..</p>
<pre class="literal-block">
role/voter/05 Allen,Woody.row
role/voter/1 Jones,Bob.row
role/voter/2 MacDonald,Ronald.row
role/voter/3 Mace,The.row
role/voter/4 MacGuyver,James.row
role/voter/5 Nelson,Willie.row
</pre>
<p>This works, of course, because &quot;<tt class="docutils literal">05 xxx</tt>&quot; sorts before &quot;<tt class="docutils literal">1
yyy</tt>&quot;, regardless of the values of &quot;<tt class="docutils literal">xxx</tt>&quot; and &quot;<tt class="docutils literal">yyy</tt>&quot;.  So, as
you can see, there are an infinite number of numbers before and
after every non-zero number you can summon.</p>
<p>The sort number may never be all zeroes.</p>
<p>If the primary key of the table is a hash or UUID, or its type
otherwise guarantees that its filename representation matches the
sort order of the type, then the sort numbers may be safely omitted.
They are enabled or disabled in the schema.</p>
</li>
</ul>
</div>
<div class="section" id="official-row-filenames">
<h1>Official row filenames</h1>
<p>As noted in the <a class="reference external" href="./filenames.html">Filename layer</a>, the &quot;official&quot; filename of the row
is that which is stripped of all of these divisions (and sort numbers)
along the way, and with no extension.  This is important for
heirarchical references to rows, which are always by the &quot;official&quot;
filename.</p>
</div>
<div class="section" id="row-format">
<h1>Row format</h1>
<p>The format of the actual rows is described in the <a class="reference external" href="./columnformat.html">ColumnFormat</a>.</p>
<p>If any columns are specified completely in the directory path of the
row, then those columns may be omitted in the stored row(s).  Tree
rebalancers beware.</p>
<p>This does not affect column numbering; the first column is likely to
have a non-zero increment value.</p>
</div>
<div class="section" id="page-format">
<h1>Page format</h1>
<p>Especially if there is a lot of relatively static rows, it may make
sense to write out &quot;pages&quot;, which are a single emission of packed
rows.</p>
<p>This is indicated in the tree by a filename which is a range, and
which is a blob (file) and not a tree (folder/directory).  Another
possibility is that the filename does not completely have all the keys
in the schema listed yet; eg if there are 3 primary key columns, and
you encounter the blob while scanning:</p>
<pre class="literal-block">
myschema/mytable/customerid,projectid.page
</pre>
<p>The third key is still expected and so the system knows that the blob
is a page and contains the remaining columns.  So, the <tt class="docutils literal">.page</tt> part
is really just a hint; other encodings which can hold multiple rows
may not have a distinction in their filename.</p>
<p>For bulk inserts, emitting pages as you go is fair game.</p>
<p>If a row in a page needs to be removed, or a value in between added,
then the page must be split or rewritten.  Most random writers will
use the split policy; rewriting a page for an update should be
considered the same problem as tree rebalancing; don't overdo it,
because it wins you relatively little and slows updates down
tremendously.</p>
</div>
</div>

  </div>

  <div id="footer" style="clear: both">
   <hr />
   <a href="../copyright.html">copyright info</a> |
   <a href="../map.html">site map</a>
  </div>

</body>
</html>
