[% title = "ColumnFormat: value packing" %]

<h2>Column Format Basics</h2>

The basic idea is taken from Google's ProtocolBuffers.  Columns are
indexed by number, starting from 0.  Each column in the row is
introduced with a variable-length signed integer, encoded as per the
<a href="[%link('design/encoding.tt')%]">Encoding rules</a>, encoding
the column number and the encoding type of the value which follows.

The lowest four bits of this number are interpreted as an enumerated
type indicator for the value which follows; this is enough to scan the
row into columns without a schema, though not enough to interpret the
values fully.

The remaining top bits of the decoded integer indicate the column
number.  This is a relative number added to the next expected column.
The number is relative to avoid two-byte sequences as much as
possible, leave more room for type bits in the normal case and to
hopefully improve compression ratios over absolute column numbering.

<div style="text-align: center; width: 85%; padding: 0.5em">
  <img src="[% link('files/columnformat.png') %]" alt="diagram showing binary representation of a two-column row"  style="width: 50em; padding: 0.3em" /><br />
  <i><b>Figure 1.</b> an example byte sequence, encoding (42,
    "42")</i>
</div>

The column offset must be added to the next expected column.  If this
is '0' then it means that the column which appears is the next column.
A number such as '2' means that there were two NULL columns (or
columns dropped before this row was written) in between the last
column read and this one.

A negative number means that the columns are appearing out of order;
for example, the primary key was not set to the first defined columns
in the original schema.  These situations should be rare and hopefully
may be excluded by some implementations and remain generally
interoperable.

<h2>Column types</h2>

The meaning of the 4-bit type field is given below.  Some of these
come from ProtocolBuffer.

As the standard is still in early RFC stage, less important encoding
types are encoded in <span style="color: grey">grey</span>; if the
important types can be reduced to 8 or fewer then the width of the
type field could be reduced to 3 as in ProtocolBuffers, but it is
thought that the current split allows for good extensibility and is
well huffmanized as it is.

<table>
  <thead>
    <tr>
      <th>type bits</th>
      <th>ASCII</th>
      <th>type name</th>
      <th>description</th>
      <th>follows</th>
      <th>formulae (Numerics)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0000</td>
      <td><span style="font-size: x-large">&#x2400;</span></td>
      <td><tt>varint</tt></td>
      <td>Integer</td>
      <td><tt>varint</tt> <var>N</var></td>
      <td><var>N</var></td>
    </tr>
    <tr>
      <td>0001</td>
      <td><span style="font-size: x-large">&#x2401;</span></td>
      <td><tt>float</tt></td>
      <td>Floating Point</td>
      <td><tt>varint</tt> <var>E</var>, <var>M</var></td>
      <td><var><var>M</var>&nbsp;×&nbsp;2<sup><var>E</var></sup></var></td>
    </tr>
    <tr>
      <td>0010</td>
      <td><span style="font-size: x-large">&#x2402;</span></td>
      <td><tt>string</tt></td>
      <td>Text or Binary data</td>
      <td><tt>varuint</tt> <var>L</var>, <var>L</var> bytes of data</td>
    </tr>
    <tr>
      <td>0011</td>
      <td><span style="font-size: x-large">&#x2403;</span></td>
      <td><tt>decimal</tt></td>
      <td>Decimal Numbers</td>
      <td><tt>varint</tt> <var>E</var>, <var>M</var></td>
      <td><var><var>M</var>&nbsp;×&nbsp;10<sup><var>E</var></sup></var></td>
    </tr>
    <tr style="color: grey">
      <td>0100</td>
      <td><span style="font-size: x-large">&#x2404;</span></td>
      <td><tt>rational</tt></td>
      <td>Rational Numbers (Fractions)</td>
      <td><tt>varint</tt> <var>N</var>, <tt>varuint</tt> D</td>
      <td><var><var>N</var>&nbsp;÷&nbsp;D</var></td>
    </tr>
    <tr>
      <td>0101</td>
      <td><span style="font-size: x-large">&#x2405;</span></td>
      <td><tt>false</tt></td>
      <td>Boolean (false)</td>
      <td>none</td>
    </tr>
    <tr>
      <td>0110</td>
      <td><span style="font-size: x-large">&#x2406;</span></td>
      <td><tt>true</tt></td>
      <td>Boolean (true)</td>
      <td>none</td>
    </tr>
    <tr>
      <td>0111</td>
      <td><span style="font-size: x-large">&#x2407;</span></td>
      <td><tt>lob</tt></td>
      <td>Large Object - oversized value</td>
      <td><tt>varuint</tt> <var>L</var>, <var>L</var> utf-8 bytes of filename</td>
    </tr>
    <tr style="color: grey">
      <td>1000</td>
      <td><span style="font-size: x-large">&#x2408;</span></td>
      <td>-</td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>1001</td>
      <td><span style="font-size: x-large">&#x2409;</span></td>
      <td><tt>null</tt></td>
      <td>explicit/resetting NULL</td>
      <td>none</td>
    </tr>
    <tr>
      <td>1010</td>
      <td><span style="font-size: x-large">&#x240a;</span></td>
      <td><tt>eor</tt></td>
      <td>Row divider in row pages</td>
      <td>none (next row)</td>
    </tr>
    <tr style="color: grey">
      <td>1011</td>
      <td><span style="font-size: x-large">&#x240b;</span></td>
      <td><tt>rowleft</tt></td>
      <td>For fast scanning of pages by primary key</td>
      <td><tt>varuint</tt> <var>L</var> (bytes of rest of row, excluding <tt>eor</tt>)</td>
    </tr>
    <tr style="color: grey">
      <td>1100</td>
      <td><span style="font-size: x-large">&#x240c;</span></td>
      <td>-</td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>1101</td>
      <td><span style="font-size: x-large">&#x240d;</span></td>
      <td><tt>reset</tt></td>
      <td>Reset column index to 0 (or offset)</td>
    </tr>
    <tr style="color: grey">
      <td>1110</td>
      <td><span style="font-size: x-large">&#x240e;</span></td>
      <td><tt>push</tt></td>
      <td>Reserved for arrays and nested types</td>
      <td>a new row</td>
    </tr>
    <tr style="color: grey">
      <td>1111</td>
      <td><span style="font-size: x-large">&#x240f;</span></td>
      <td><tt>pop</tt></td>
      <td>Reserved for arrays and nested types</td>
      <td>remainder of row</td>
    </tr>
  </tbody>
</table>

The ASCII column reminds you what ASCII control character you will see
if you end up directly inspecting heap contents (and the column offset
is 0).

<h3>Boolean values</h3>

There are two types assigned to booleans, effectively squeezing the
value into the type code header.

Some standard types will have functions which decide on the
appropriate encoding based on the value; booleans are one of them.

<h3>Streaming features</h3>

As in ProtocolBuffer, well formed rows from two sources can be merged
by string concatenation, except using the ASCII carriage return (CR)
character between them, which encodes a 'Reset' column.  Normally it
is not necessary to encode NULL column values; leaving them out is
equivalent, but in the context of combining rows this may be useful.
Explicit NULL values should never appear in stored rows or pages; it
is reserved for stream use in situations where it is required.

<h3>Page feature types</h3>

Two types are added for paged rows - blobs which contain multiple
rows.  Paging allows for "table compression" to work, useful for
improving OLAP disk space use and scan requirements.  Some
implementations may choose to omit all support for row paging.

First, there is the <tt>eor</tt> marker, which allows for delimiting
rows in a page.

Secondly, there is the <tt>rowleft</tt> type which appears after the
primary key columns, to allow faster scanning by primary key in pages.
Instead of decoding all columns on the way to the next row, the next
primary key can be immediately located.  The <tt>rowleft</tt> type
encodes a <tt>varuint</tt> which is the length of the data columns in
bytes; skipping that many bytes forward should land you on an
<tt>eor</tt> marker.

<h3>Large Objects (LOBs)</h3>

For larger column values, they may have their data saved in their own
blob instead of stored in the page using the 'string' code.

Postgres calls this feature "toast" tables.

The value is a string, a filename.  The filename is stored in the git
tree, and a reference counting back-reference to the row will be
required to be able to effectively manage that.

<h3>Arrays and Nested Types</h3>

Some attributes are arrays; others are structured value types.  This
is different to a foreign key; they are non-relational entities, which
are only accessible from the parent object.  They let you avoid joins
when the values stored are true value types, but being non-relational
you cannot place unique constraints on them, or refer to them as
discrete entities.  They also let you get many of the benefits of
document stores, but with much stronger type checking along the way.

Postgres has this sort of functionality built into it, and it works
quite well.  For now, <tt>push</tt> and <tt>pop</tt> are merely
reserved.

<h3>Schema changes</h3>

When columns are added, they get a new number, and, when they are
deleted, the numbers are not re-used.  This is done so that
frequently, schema modifications do not require major changes to the
table data.

Lazy schema change operations might not mop up all of the columns
which no longer exist; cleaning this up is akin to a VACUUM operation.

