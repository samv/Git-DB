..

   restindex
   /restindex

=====================================
MetaFormat: specifying data structure
=====================================

.. figure:: ../files/meta-uml-simple.png
   :width: 40%
   :figwidth: 80%
   :alt: UML diagram showing relationship between meta concepts
   :align: right

   **Figure 1.** How the various ``meta`` types relate to each other,
   as UML.  This is a simplified overview.

There is a special schema in the git db store which represents the
schema of the tables itself; these are identified with the ``meta.``
schema name.  Optionally there are rows in the schema which represent
the schema of the ``meta.`` store itself.

Meta Tables
===========

As the intrinsic storage building block, the ``meta.`` schema defines
the tables that exist in the store.

The ``meta.`` schema is rich enough to express itself, as well as a
number of useful features such as inheritance, nested tuples, and
basic keys.

There are four groups of ``meta`` tables:

**schema**

   The objects in this table are top-level containers for all the
   schema objects relating to a particular version of the application.
   When querying, this specifies the name that can be used to specify
   the schema for objects.

**types**

   The type system uses (strict) inheritance, with all types sharing a
   common (abstract) base type, ``meta.types``.

   As is described later, this also implies that they share a primary
   key.  This is different to Postgres, on which inherited types do
   not share keys.  In the ``meta`` schema, they will also share the
   same storage path, ``/meta/types``.

   Types can be value types (``meta.value``), tuples (``meta.tuple``)
   or storage tables (``meta.table``).

**attributes**

   Tuples are comprised of an ordered set of attributes.  Taken
   together, these attributes define the tuple type.

   Each attribute has a type, which can be a basic type or a tuple, as
   described above.

**keys**

   There are three types of keys.  Primary keys, foreign keys, and
   unique keys.  Every key belongs to a table (called the *source*
   table), and all the attributes that it refers to are found in the
   source table.  There are no indexes in this version of gitdb.


The Schema table (``meta.schema``)
==================================

The schema table defines local names of the schemas used.  This
controls the path where the data lives in the top level of the
repository.  It also allows for schema revisioning.  The repository
revision is a ``num``, which can be any number; integer, decimal,
float etc.  This number can be used for schema revisioning.

::

  meta.schema:
    ns_url text not null
    ns_rev num not null
    primary key (ns_url, ns_rev)
    ns_name str not null
    foreign key (ns_name) references :ns_name_idx
 
  meta.schema:ns_name_idx
    ns_name str not null
    primary key (ns_name)

Specified in a more Avro-like JSON syntax, that would be:

::

   { "name": "schema",
     "type": "tuple",
     "fields": [
        { "attr_name": "ns_url", "type": "string", "required": 1 },
        { "name": "ns_rev", "type": "num", "required": 1 },
        { "name": "ns_name", "type": "string", "required": 1 },
     ],
     "keys": [
        { "primary": true,
          "fields": [ "ns_url", "ns_rev" ] },
        { "unique": true,
          "fields": [ "ns_name" ],
         },
     ],
   }

The values, for the ``meta`` schema, are:

::

   [ "http://github.com/samv/Git-DB", 0.1, "meta" ]

Which would be encoded as:

::

  00000000  021d 6874 7470 3a2f 2f67 6974 6875 622e  ␂␝http://github.
  00000010  636f 6d2f 7361 6d76 2f47 6974 2d44 4203  com/samv/Git-DB␃
  00000020  7f01 0204 6d65 7461                      ␡␁␂␄meta

This shows a curious situation, in that it is possible to include
information in the ``meta`` tables about the ``meta`` schema itself.
This is a well-known chicken-and-egg situation, found in type theory,
metaprogramming, etc.

To keep things simple when connecting, all that is required is a
single row which includes the ``meta`` schema URL and revision - and
if the implementation does not know how what that means, it cannot
process the rest of the schema metadata, and therefore should not
continue.  If the data is provided, then it should be compared against
the known good data, and any discrepancies treated as a fatal error.


Types (``meta.type``)
======================

Types are abstract, in that you can't just have a type, it has to be a
particular kind of type.  When reading the row, which kind of type you
have can be distinguished from which attributes it posesses.

The ``type`` tuple exists only to keep a registry of type names, and
index values.  To allow for renaming without having to alter table
content, there is a normative index, an integer, and a type name.

::

  { "tuple_name": "type",
    "attr": [
       { "name": "ns_url", "type": "string", "required": true },
       { "name": "ns_rev", "type": "num", "required": true },
       { "name": "type_index", "type": "int", "required": true },
       { "name": "type_name", "type": "string", "required": true },
    ],
    "keys": [
       { "primary": true,
         "key_fields": [ "ns_url", "ns_rev", "tuple_index" ]
       },
       { "foreign": true,
         "fields": [ "ns_url", "ns_rev" ],
         "references": {
             "tuple_name": "schema",
             "key": "__primary__",
         }
       }
    ]
  }

.. thought: are primary keys not also tuples, perhaps called
   ``ns.table.__primary__`` ?

Value Types (``meta.value``)
----------------------------

Value Types are a kind of type that are simple and concrete: they have
a single set of allowable column formats, and well-known set of
functions for converting from the value to representations such as the
tree format and the column format.

::

  { "tuple_name": "value",
    "tuple_inherit": [ "type" ],
    "attr": [
        { "name": "value_formats", type: "int", "required": true },
        { "name": "value_dump_f", type: "string", "required": false },
        { "name": "value_load_f", type: "string", "required": false },
        { "name": "value_choose_f", type: "string", "required": false },
        { "name": "value_cmp_f", type: "string", "required": false },
        { "name": "value_print_f", type: "string", "required": false },
        { "name": "value_scan_f", type: "string", "required": false },
    ],

Value Type definitions are relatively mundane, so the meanings of
these columns is described elsewhere, in `Value Types`_.

Tuples (``meta.tuple``)
-----------------------

The tuple table defines what Postgres would call compound data types,
and are usually called tables in the classic RDBMS, or perhaps classes
or result sets in other contexts.

Similar to the situation in Postgres, they are not necessarily
intended for use as real tables, and can be used as column types in
the case of nested data types.  This allows for deeply nested data in
rows, though it is still strictly typed.

Tuples can inherit from other tuples, but they must add at least one
required attribute in order to distinguish themselves in storage.
This restriction allows typical cases to work naturally, and avoid
unnecessary typing information having to be specified in the column
format.

Types within an inheritance heirarchy share attribute numbering
ranges.

::

   { "tuple_name": "tuple",
     "tuple_inherit": [ "type" ],
     "attr": [
        { "name": "tuple_super", "type": "int", "dimensions": 1,
          "required": 0 },
     ],
     "keys": [
        { "foreign": "1",
          "fields": [ "ns_url", "ns_rev", "tuple_super" ],
          "references": {
              "type_name": "tuple",
              "key_name": "__primary__",
          }
        },
     ],
   },

Storage Tables (``meta.table``)
-------------------------------

A tuple with storage is called a table.

By default, its storage path is ``/ns_name/type_name`` - but this can
be overridden by a non-null value in the ``table_path`` column.  The
only fixed path in the repository is therefore ``/meta`` - though you
can call this path ``/_meta`` or ``/.meta`` if you prefer.  On
connection, they should be tried in that order, and the first one
found used.  If a ``value_name`` is used in the schema, but not listed
in ``meta.types``, then the above definitions are used.

::

   { "tuple_name": "table",
     "tuple_inherit": [ "tuple" ],
     "attr": [
        { "name": "table_path", "type": "string", "required": 1 },
     ],
   }


The Attribute table (``meta.attr``)
===================================

Tuples are lists of attributes.  For now, the attributes table is a
foreign key against the "tuple" table.

::

  { "name": "attr",
    "type": "tuple",
     "fields": [
        { "name": "ns_url", "type": "string", "required": 1 },
        { "name": "ns_rev", "type": "num", "required": 1 },
        { "name": "tuple_index", "type": "int", "required": 1 },
        { "name": "attr_index", "type": "string", "required": 1 },
        /* attr_name: unique, so deleted columns have no name */
        { "name": "attr_name", "type": "string", "required": 0 },
        /* type can reference tuple, because tuples are types */
        { "name": "attr_type", "type": "text", "required": 1 },
        /* dimensions: if the attribute is an array */
        { "name": "attr_dim", "type": "int", "required": 0 },
     ],

     "keys": [
        { "keytype": "primary",
          "fields": [ "ns_url", "ns_rev", "tuple_index", "attr_index" ],
        },
        { "keytype": "unique",
          "fields": [ "ns_url", "ns_rev", "tuple_name", "attr_name" ],
        },
        { "keytype": "foreign",
          "fields": [ "ns_url", "ns_rev", "tuple_index" ],
          "references": {
              "ns_name": "meta",
              "tuple_name": "tuple",
          }
        },
        { "keytype": "foreign",
          "fields": [ "ns_url", "ns_rev", "attr_type" ],
          "references": {
              "ns_name": "meta",
              "tuple_name": "type",
              "fields": [ "ns_url", "ns_rev", "attr_type" ],
          }
        },
     ],
  }

To explain all this;

``ns_url``, ``ns_rev``, ``tuple_index``

    These are the foreign keys to the ``tuple`` table.  They specify
    the ``meta.tuple`` that the entry describes.

``attr_index``

    This specifies the column number in storage.  When new columns are
    added, they are given a new ``attr_index`` number.  When they are
    renamed, the number stays the same, and finally, when they are
    deleted the entry remains.

``attr_name``

    This is the logical name that is ascribed to the property, and
    should be the important one as far as applications are concerned.
    As there is a unique constraint, attributes which are deleted
    should have this ``attr_name`` set to null.

``attr_type``

    This specifies the type of the attribute.  It is a reference to
    the ``meta.types`` table.  Through inheritance, this may also
    refer to tuples in the ``meta.tuple`` table - even itself.
    Cross-schema type references are not allowed.

``attr_dim``

    This specifies the number of dimensions of the attribute.  If it
    is 0 or not specified, then the attribute is a regular attribute.
    If it is 1, then it is an array.  If 2 or higher, a
    multi-dimensional array.

    One key caveat here is that array attributes must be homogenous,
    or at least have a common base type, such that 

KEYS & UNIQUE CONSTRAINTS
=========================

There are three types of indexes: primary keys, unique keys, and
foreign keys.

::

  { "name": "key",
    "type": "tuple",
     "fields": [
        { "name": "ns_url", "type": "string", "required": 1 },
        { "name": "ns_rev", "type": "num", "required": 1 },
        { "name": "tuple_index", "type": "int", "required": 1 },
        { "name": "key_name", "type": "string", "required": 1 },
        { "name": "key_unique", "type": "boolean", "required": 1 },
        { "name": "key_primary", "type": "boolean", "required": 1 },
        { "name": "key_foreign", "type": "boolean", "required": 1 },
        { "name": "key_inherit", "type": "boolean", "required": 1 },
        { "name": "key_source_tuple", "type": "int", "required": 1 },
        { "name": "key_source_idx", "type": "int", "dimensions": 1,
          "required": 1 },
        { "name": "key_dest_tuple", "type": "int", "required": 1 },
        { "name": "key_dest_idx", "type": "int", "dimensions": 1,
          "required": 1 }
     ],
     "keys": [
        { "keytype": "primary",
          "fields": [ "ns_url", "ns_rev", "tuple_index", "key_name" ],
        },
        { "keytype": "foreign",
          "fields": [ "ns_url", "ns_rev", "tuple_index" ],
          "references": {
              "ns_name": "meta",
              "tuple_name": "tuple",
          }
        },
        { "keytype": "foreign",
          "fields": [ "ns_url", "ns_rev", "key_source_tuple",
                      "key_source_idx" ],
          "references": {
              "ns_name": "meta",
              "tuple_name": "attr",
              "fields": [ "ns_url", "ns_rev", "tuple_index",
                          "attr_index" ]
          }
        },
        { "keytype": "foreign",
          "fields": [ "ns_url", "ns_rev", "key_dest_tuple",
                      "key_dest_idx" ],
          "references": {
              "ns_name": "meta",
              "tuple_name": "attr",
              "fields": [ "ns_url", "ns_rev", "tuple_index",
                          "attr_index" ]
          }
        }
     ]
  }

   Unique keys add the notion of constraint on the source table, and
   add a required field: whether or not the required index is in
   storage or not.  For applications where the storage or transmission
   size of the database is the most important concern, this will be
   false.  If it is stored, it is stored in TreeFormat (and therefore,
   may have a storage path).

   .. the primary key defines a tuple as being a table.  discuss.

   The only difference between the primary key and a unique key is
   that it is used as the primary identity for rows in the table.  As
   there are no real extra fields, the primary key is distinguished by
   a ``key_primary`` boolean attribute, and in storage they are the
   same type ID.

   Finally, there is the ``foreign`` key type.  Foreign keys refer to
   another key.  If they refer to a unique or primary key, a
   traditional foreign key relationship is established.  Foreign keys
   which refer to each other imply the existence test, but place no
   constraint on uniqueness of either side.


.. _TreeFormat:
   ./treeformat.html

.. _Value Types:
   ./values.html
